BlueBird Runtime SystemWelcome to the BlueBird Runtime, the engine that powers the execution of BlueBird programs. This runtime is written in Rust to guarantee memory safety and provide a "zero-cost abstraction" foundation, ensuring that high-level BlueBird features translate to highly efficient machine code.The runtime is designed to be minimal, modular, and extensible. It does not include a garbage collector; memory is managed deterministically through the same ownership and borrowing principles that the BlueBird compiler enforces.Core ComponentsThe runtime is structured into four primary modules:Allocator: A high-performance memory allocator responsible for handling heap allocations for dynamic data structures like list and string. It ensures fast allocation and immediate deallocation when an object goes out of scope.Concurrency: A lightweight, asynchronous task scheduler built on a work-stealing thread pool. It manages the execution of BlueBird's spawn blocks, enabling massive concurrency with minimal overhead.Matrix Engine: The computational core for BlueBird's first-class Matrix type. It uses SIMD (Single Instruction, Multiple Data) optimizations to execute matrix operations at native hardware speed.API Layer: An interface that translates BlueBird's declarative api blocks into a high-performance, asynchronous web server, capable of handling thousands of simultaneous connections.Architectural DiagramThis diagram illustrates how a compiled BlueBird program interacts with the runtime modules and the underlying operating system.Design PhilosophySafety First: Leverage Rust's type system and borrow checker to eliminate entire classes of runtime errors.Performance by Default: Provide abstractions that are both high-level and zero-cost. The developer writes clean BlueBird code, and the runtime ensures it executes efficiently.Clear Boundaries: Each module is self-contained with a well-defined public API, making the system easier to maintain, test, and extend.