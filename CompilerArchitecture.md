BlueBird Compiler ArchitectureThe BlueBird compiler, bluebirdc, is designed as a modular pipeline that transforms BlueBird source code into a highly optimized executable. It leverages the LLVM compiler infrastructure for its backend, allowing it to produce fast machine code for multiple architectures.The Compilation StagesParsing (Frontend):Lexer: The source code (.bb file) is scanned and broken down into a stream of tokens (e.g., let, identifier, number).Parser: The tokens are organized into an Abstract Syntax Tree (AST), a hierarchical tree that represents the code's structure.Semantic Analysis (Mid-end):Type Checker: This stage traverses the AST to ensure all type rules are followed. It catches errors like trying to add a string to an integer.Borrow Checker: This is the core of BlueBird's safety model. It analyzes the lifetimes and ownership of variables to prevent memory errors like data races and use-after-free bugs at compile time.Code Generation (Backend):LLVM IR Generation: The verified AST is translated into LLVM Intermediate Representation (IR), a low-level, platform-independent assembly language.Optimization & Code Generation: LLVM runs numerous optimization passes on the IR and then compiles it into native machine code for the target architecture (e.g., x86-64, ARM).